.###  This whole script runs in template mode.
.#
.# Generates a low level Qt/C++ Machinetalk channel
.#
.template 1
.gsl from "scripts/prepare_fsm.gsl"
.gsl from "scripts/prepare_msg.gsl"
.gsl from "scripts/prepare_socket.gsl"
.
.macro writeHeader()
/****************************************************************************
**
** This file was generated by a code generator based on imatix/gsl
** Any changes in this file will be lost.
**
****************************************************************************/
.endmacro
.
.path = "generated/qt/$(project:c)/$(class.module:Pascal,lower)"
.output path + "/$(class.name:Pascal,lower).h"
.writeHeader()
#ifndef $(class.MODULE:c)_$(class.NAME:c)_H
#define $(class.MODULE:c)_$(class.NAME:c)_H
#include <QObject>
#include <QSet>
#include <QDebug>
.if defined(class->socket.class)
#include <QQmlParserStatus>
.endif
.if count(timer) > 0
#include <QTimer>
.endif
#include <nzmqt/nzmqt.hpp>
#include <$(project:c)/protobuf/message.pb.h>
.for socket where (defined(socket.class))
#include "../$(socket.module:Pascal,lower)/$(socket.class:Pascal,lower).h"
.endfor

namespace $(class.project:Pascal,lower) { namespace $(class.module:Pascal,lower) {

class $(class.name:lower,Pascal)
    : public QObject
.if defined(class->socket.class)
    , public QQmlParserStatus
.endif
{
    Q_OBJECT
.if defined(class->socket.class)
    Q_INTERFACES(QQmlParserStatus)
.endif
    Q_PROPERTY(bool ready READ ready WRITE setReady NOTIFY readyChanged)
.for socket
    Q_PROPERTY(QString $(name)Uri READ $(name)Uri WRITE set$(Name)Uri NOTIFY $(name)UriChanged)
.endfor
    Q_PROPERTY(QString debugName READ debugName WRITE setDebugName NOTIFY debugNameChanged)
    Q_PROPERTY(State connectionState READ state NOTIFY stateChanged)
    Q_PROPERTY(QString errorString READ errorString NOTIFY errorStringChanged)
.for timer
    Q_PROPERTY(int $(name)Interval READ $(name)Interval WRITE set$(Name)Interval NOTIFY $(name)IntervalChanged)
.endfor
.- timer of channel
.for socket
.  for timer
    Q_PROPERTY(int $(socket.name:lower,Camel)$(Name)Interval READ $(socket.name:lower,Camel)$(Name)Interval WRITE set$(socket.name:lower,Pascal)$(Name)Interval NOTIFY $(socket.name:lower,Camel)$(Name)IntervalChanged)
.  endfor
.endfor
    Q_ENUMS(State)

public:
    explicit $(class.name:lower,Pascal)(QObject *parent = nullptr);
    ~$(class.name:lower,Pascal)();

.for fsm
    enum class State {
.  for state
        $(Name) = $(index(state)-1),
.  endfor
    };
.endfor
.
.if defined(class->socket.class)

    void classBegin() {}
    /** componentComplete is executed when the QML component is fully loaded */
    void componentComplete()
    {
        m_componentCompleted = true;

        if (m_ready == true)    // the component was set to ready before it was completed
        {
            start();
        }
    }
.endif
.
.for socket

    QString $(name)Uri() const
    {
.  if defined(socket.class)
        return m_$(name)Channel->socketUri();
.  else
        return m_$(name)Uri;
.  endif
    }
.endfor

    QString debugName() const
    {
        return m_debugName;
    }

    State state() const
    {
        return m_state;
    }

    QString errorString() const
    {
        return m_errorString;
    }
.for timer

    int $(name)Interval() const
    {
        return m_$(name)Interval;
    }
.endfor
.- timer of channels
.for socket
.  for timer

    int $(socket.name:lower,Camel)$(Name)Interval() const
    {
        return m_$(socket.name:lower,Camel)Channel->$(name)Interval();
    }
.  endfor
.endfor

    bool ready() const
    {
        return m_ready;
    }

public slots:
.for socket

    void set$(Name)Uri(const QString &uri)
    {
.  if defined(socket.class)
        m_$(name)Channel->setSocketUri(uri);
.  else
        if (m_$(name)Uri == uri) {
            return;
        }

        m_$(name)Uri = uri;
        emit $(name)UriChanged(uri);
.  endif
    }
.endfor

    void setDebugName(const QString &debugName)
    {
        if (m_debugName == debugName) {
            return;
        }

        m_debugName = debugName;
        emit debugNameChanged(debugName);
    }
.for timer

    void set$(Name)Interval(int interval)
    {
        if (m_$(name)Interval == interval) {
            return;
        }

        m_$(name)Interval = interval;
        emit $(name)IntervalChanged(interval);
    }
.endfor
.- timer of channels
.for socket
.  for timer

    void set$(socket.name:lower,Pascal)$(Name)Interval(int interval)
    {
        m_$(socket.name:lower,Camel)Channel->set$(Name)Interval(interval);
    }
.  endfor
.endfor

    void setReady(bool ready)
    {
        if (m_ready == ready) {
            return;
        }

        m_ready = ready;
        emit readyChanged(ready);
.if defined(class->socket.class)

        if (m_componentCompleted == false)
        {
            return;
        }
.endif

        if (m_ready)
        {
            start();
        }
        else
        {
            stop();
        }
    }

.
.for socket
.  if (count(outgoing) > 0)

.    if ((type = "XPUB") | (type = "ROUTER"))
    void send$(Name)Message(const QByteArray &topic, ContainerType type, Container &tx);
.    else
    void send$(Name)Message(ContainerType type, Container &tx);
.    endif
.  endif
.
.  for outgoing where ((name <> "*") & (defined(public)))
.    if ((socket.type = "XPUB") | (socket.type = "ROUTER"))
    void send$(name:Pascal)(const QByteArray &topic, Container &tx);
.    else
    void send$(name:Pascal)(Container &tx);
.    endif
.  endfor
.endfor
.
.for socket
.  if ((type = "SUB") | (type = "XPUB"))
    void add$(Name)Topic(const QByteArray &name);
    void remove$(Name)Topic(const QByteArray &name);
    void clear$(Name)Topics();
.  endif
.endfor

protected:
.for trigger
    void $(name:Camel)(); // $(name) trigger
.endfor

private:
.if defined(class->socket.class)
    bool m_componentCompleted;
.endif
    bool m_ready;
    QString m_debugName;

.for socket
.  if ((type = "SUB" | (type = "XPUB")))
    QSet<QByteArray> m_$(name)Topics;  // the topics we are interested in
.  endif
.  if defined(socket.class)
    $(socket.module:Pascal,lower)::$(socket.class:lower,Pascal) *m_$(name)Channel;
.  else
    QString m_socketUri;
    nzmqt::PollingZMQContext *m_context;
    nzmqt::ZMQSocket *m_socket;
.  endif
.endfor
.

    State         m_state;
    State         m_previousState;
    QString       m_errorString;
.
.for timer

    QTimer      m_$(name)Timer;
    int         m_$(name)Interval;
.  if (defined(liveness))
    int         m_$(name)Liveness;
    int         m_$(name)ResetLiveness;
.  endif
.endfor
    // more efficient to reuse a protobuf Messages
.for socket
.  if (count(incoming) > 0)
    Container m_$(name)Rx;
.  endif
.  if (count(outgoing) > 0)
    Container m_$(name)Tx;
.  endif
.endfor

private slots:
.for timer

    void $(name)TimerTick();
.  if (defined(liveness))
    void reset$(Name)Liveness();
.  endif
    void reset$(Name)Timer();
    void start$(Name)Timer();
    void stop$(Name)Timer();
.endfor
.
.for socket

.  if defined(socket.class)
    void start$(Name)Channel();
    void stop$(Name)Channel();
.    if (count(state) > 0)
    void $(name)ChannelStateChanged($(socket.module:Pascal,lower)::$(socket.class:lower,Pascal)::State state);
.    endif
.    if (count(incoming) > 0)
.      if ((type = "SUB") | (type = "ROUTER"))
    void process$(Name)ChannelMessage(const QByteArray &topic, const Container &rx);
.      else
    void process$(Name)ChannelMessage(const Container &rx);
.      endif
.    endif
.  else
    bool startSocket();
    void stopSocket();

.    if (count(incoming) > 0)
    void processSocketMessage(const QList<QByteArray> &messageList);
.    endif
    void socketError(int errorNum, const QString &errorMsg);

.  endif
.
.  for outgoing where ((name <> "*") & (!defined(public)))
    void send$(name:Pascal)();
.  endfor
.endfor
.

.for fsm
.  for state
    void fsm$(Name)();
.    for entry
    void fsm$(Name)Entry();
.    endfor
.    for exit
    void fsm$(Name)Exit();
.    endfor
.    for event
    void fsm$(state.Name)$(Name:Pascal)Event();
.    endfor
.  endfor
.endfor

.for socket
.  for incoming where (defined(public) & (public = "true"))
.    if ((socket.type = "SUB") | (socket.type = "ROUTER"))
    virtual void handle$(name:Pascal)Message(const QByteArray &topic, const Container &rx) = 0;
.    else
    virtual void handle$(name:Pascal)Message(const Container &rx) = 0;
.    endif
.  endfor
.endfor
.
.for slot
    virtual void $(name:Camel)() = 0;
.endfor
.

signals:
.for socket
    void $(name)UriChanged(const QString &uri);
.endfor
.
.for socket
.  if (count(incoming) > 0)
.    if ((type = "SUB") | (type = "ROUTER"))
    void $(name)MessageReceived(const QByteArray &topic, const Container &rx);
.    else
    void $(name)MessageReceived(const Container &rx);
.    endif
.  endif
.endfor
.
    void debugNameChanged(const QString &debugName);
    void stateChanged($(class.name:lower,Pascal)::State state);
    void errorStringChanged(const QString &errorString);
.for timer
    void $(name)IntervalChanged(int interval);
.endfor
.- timer of channel
.for socket
.  for timer
    void $(socket.name:lower,Camel)$(Name)IntervalChanged(int interval);
.  endfor
.endfor
    void readyChanged(bool ready);
    // fsm
.for fsm
.  for state
    void fsm$(state.name:Pascal)Entered(QPrivateSignal);
    void fsm$(state.name:Pascal)Exited(QPrivateSignal);
.    for event
    void fsm$(state.Name)$(Name:Pascal)(QPrivateSignal);
.    endfor
.  endfor
.endfor
};

} } // namespace $(class.project:Pascal,lower)::$(class.module:Pascal,lower)
#endif // $(class.MODULE:c)_$(class.NAME:c)_H
.endtemplate
.
.############################################################################
.# Cpp file
.############################################################################
.
.template 1
.output path + "/$(class.name:Pascal,lower).cpp"
.writeHeader()
#include "$(class.name:Pascal,lower).h"
#include <google/protobuf/text_format.h>
#include "debughelper.h"

#if defined(Q_OS_IOS)
namespace gpb = google_public::protobuf;
#else
namespace gpb = google::protobuf;
#endif

using namespace nzmqt;

namespace $(class.project:Pascal,lower) { namespace $(class.module:Pascal,lower) {

/** Generic $(class.name:) implementation */
$(class.name:lower,Pascal)::$(class.name:lower,Pascal)(QObject *parent)
    : QObject(parent)
.if defined(class->socket.class)
    , QQmlParserStatus()
    , m_componentCompleted(false)
.endif
    , m_ready(false)
    , m_debugName("$(class.name:)")
.for socket
.  if defined(socket.class)
    , m_$(name)Channel(nullptr)
.  else
    , m_socketUri("")
    , m_context(nullptr)
    , m_socket(nullptr)
.  endif
.endfor
    , m_state(State::$(class->fsm.Initial))
    , m_previousState(State::$(class->fsm.Initial))
    , m_errorString("")
.for timer
    , m_$(name)Interval($(interval))
.  if (defined(liveness))
    , m_$(name)Liveness(0)
    , m_$(name)ResetLiveness($(liveness))
.  endif
.endfor
{
.for socket where defined(socket.class)
    // initialize $(name) channel
    m_$(name)Channel = new $(socket.module:Pascal,lower)::$(socket.class:lower,Pascal)(this);
    m_$(name)Channel->setDebugName(m_debugName + " - $(name:)");
    connect(m_$(name)Channel, &$(socket.module:Pascal,lower)::$(socket.class:lower,Pascal)::socketUriChanged,
            this, &$(class.name:lower,Pascal)::$(name)UriChanged);
.  if (count(state) > 0)
    connect(m_$(name)Channel, &$(socket.module:Pascal,lower)::$(socket.class:lower,Pascal)::stateChanged,
            this, &$(class.name:lower,Pascal)::$(name)ChannelStateChanged);
.  endif
.  if (count(incoming) > 0)
    connect(m_$(name)Channel, &$(socket.module:Pascal,lower)::$(socket.class:lower,Pascal)::socketMessageReceived,
            this, &$(class.name:lower,Pascal)::process$(Name)ChannelMessage);
.  endif
.endfor
.
.for timer

    m_$(name)Timer.setSingleShot(true);
    connect(&m_$(name)Timer, &QTimer::timeout, this, &$(class.name:lower,Pascal)::$(name)TimerTick);
.endfor
.- timer of channels
.for socket
.  for timer

    connect(m_$(socket.name:lower,Camel)Channel, &$(socket.module:Pascal,lower)::$(socket.class:lower,Pascal)::$(name)IntervalChanged,
            this, &$(class.name:lower,Pascal)::$(socket.name:lower,Camel)$(Name)IntervalChanged);
.  endfor
.endfor
.
.for fsm
    // state machine
.  for state
.-   entry and exit
.    for entry
    connect(this, &$(class.name:lower,Pascal)::fsm$(state.Name)Entered,
            this, &$(class.name:lower,Pascal)::fsm$(state.Name)Entry);
.    endfor
.    for exit
    connect(this, &$(class.name:lower,Pascal)::fsm$(state.Name)Exited,
            this, &$(class.name:lower,Pascal)::fsm$(state.Name)Exit);
.    endfor
.  endfor
.
.  for state
.    for event
    connect(this, &$(class.name:lower,Pascal)::fsm$(state.Name)$(event.name:Pascal),
            this, &$(class.name:lower,Pascal)::fsm$(state.Name)$(event.name:Pascal)Event);
.    endfor
.  endfor
.endfor
.
.for socket where !defined(socket.class)

    m_context = new PollingZMQContext(this, 1);
    connect(m_context, &PollingZMQContext::pollError,
            this, &$(class.name:lower,Pascal)::socketError);
    m_context->start();
.endfor
}

$(class.name:lower,Pascal)::~$(class.name:lower,Pascal)()
{
.for socket where !defined(socket.class)
    stopSocket();

    if (m_context != nullptr)
    {
        m_context->stop();
        m_context->deleteLater();
        m_context = nullptr;
    }
.endfor
}
.
.for socket
.  if ((type = "SUB") | (type = "XPUB"))

/** Add a topic that should be subscribed **/
void $(class.name:lower,Pascal)::add$(Name)Topic(const QByteArray &name)
{
.    if defined(socket.class)
    m_$(name)Channel->addSocketTopic(name);
.    else
    m_$(name)Topics.insert(name);
.    endif
}

/** Removes a topic from the list of topics that should be subscribed **/
void $(class.name:lower,Pascal)::remove$(Name)Topic(const QByteArray &name)
{
.    if defined(socket.class)
    m_$(name)Channel->removeSocketTopic(name);
.    else
    m_$(name)Topics.remove(name);
.    endif
}

/** Clears the the topics that should be subscribed **/
void $(class.name:lower,Pascal)::clear$(Name)Topics()
{
.    if defined(socket.class)
    m_$(name)Channel->clearSocketTopics();
.    else
    m_$(name)Topics.clear();
.    endif
}
.  endif
.
.  if !defined(socket.class)

/** Connects the 0MQ sockets */
bool $(class.name:lower,Pascal)::startSocket()
{
    m_socket = m_context->createSocket(ZMQSocket::TYP_$(TYPE), this);
    m_socket->setLinger(0);

    try {
.    if (nature = "client")
        m_socket->connectTo(m_socketUri);
.    else
        m_socket->bindTo(m_socketUri);
.    endif
    }
    catch (const zmq::error_t &e) {
        const QString errorString = QString("Error %1: ").arg(e.num()) + QString(e.what());
.-      TODO: updateState(SocketError, errorString);
        qCritical() << m_debugName << ":" << errorString;
        return false;
    }
.    if (count(incoming) > 0)

    connect(m_socket, &ZMQSocket::messageReceived,
            this, &$(class.name:lower,Pascal)::processSocketMessage);
.    endif

.    if (type = "SUB")

    for (const auto &topic: m_socketTopics)
    {
        m_socket->subscribeTo(topic);
    }
.    endif

#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "sockets connected" << m_socketUri);
#endif

    return true;
}

/** Disconnects the 0MQ sockets */
void $(class.name:lower,Pascal)::stopSocket()
{
    if (m_socket != nullptr)
    {
        m_socket->close();
        m_socket->deleteLater();
        m_socket = nullptr;
    }
}
.
.  endif
.endfor
.
.for socket where defined(socket.class)

void $(class.name:lower,Pascal)::start$(Name)Channel()
{
    m_$(name)Channel->setReady(true);
}

void $(class.name:lower,Pascal)::stop$(Name)Channel()
{
    m_$(name)Channel->setReady(false);
}
.endfor
.
.for timer

.  if (defined(liveness))
void $(class.name:lower,Pascal)::reset$(Name)Liveness()
{
    m_$(name)Liveness = m_$(name)ResetLiveness;
}
.  endif

void $(class.name:lower,Pascal)::reset$(Name)Timer()
{
    if (m_$(name)Timer.isActive())
    {
        m_$(name)Timer.stop();
    }

    if (m_$(name)Interval > 0)
    {
        m_$(name)Timer.setInterval(m_$(name)Interval);
        m_$(name)Timer.start();
    }
}

void $(class.name:lower,Pascal)::start$(Name)Timer()
{
    reset$(Name)Timer();
}

void $(class.name:lower,Pascal)::stop$(Name)Timer()
{
    m_$(name)Timer.stop();
}

void $(class.name:lower,Pascal)::$(name)TimerTick()
{
.  if (defined(liveness))
    m_$(name)Liveness -= 1;
    if (m_$(name)Liveness == 0)
    {
.    for timeout
.      ifprefix = ""
.      for event
         $(ifprefix)if (m_state == State::$(when:Pascal))
         {
             emit fsm$(when:Pascal)$(name:Pascal)(QPrivateSignal());
         }
.        ifprefix = "else "
.      endfor
.    endfor
         return;
    }
.  endif
.
.  for tick
.    ifprefix = ""
.    for event
    $(ifprefix)if (m_state == State::$(when:Pascal))
    {
        emit fsm$(when:Pascal)$(name:Pascal)(QPrivateSignal());
    }
.      ifprefix = "else "
.    endfor
.  endfor
}
.endfor
.
.for socket where (count(incoming) > 0)

/** Processes all message received on $(name:) */
.  if defined(socket.class)
.    if ((type = "SUB") | (type = "ROUTER"))
void $(class.name:lower,Pascal)::process$(Name)ChannelMessage(const QByteArray &topic, const Container &rx)
.    else
void $(class.name:lower,Pascal)::process$(Name)ChannelMessage(const Container &rx)
.    endif
{
.  else
void $(class.name:lower,Pascal)::processSocketMessage(const QList<QByteArray> &messageList)
{
    Container &rx = m_$(name)Rx;
.    if ((type = "SUB") | (type = "ROUTER"))

    if (messageList.length() < 2)  // in case we received insufficient data
    {
        return;
    }

    // we only handle the first two messges
    const auto &topic = messageList.first();
.-  TODO: handle multiple addresses here
.    endif
    rx.ParseFromArray(messageList.last().data(), messageList.last().size());

#ifdef QT_DEBUG
    std::string s;
    gpb::TextFormat::PrintToString(rx, &s);
    DEBUG_TAG(3, m_debugName, "received message" << QString::fromStdString(s));
#endif
.  endif
.
.  ifprefix = ""
.  for incoming
.    if (defined(ignore) | (count(event) > 0) | defined(public))

.      if (name <> "*")
.        ws = "    "
    // react to $(name) message
    $(ifprefix)if (rx.type() == $(class.msg_prefix + " " + name:upper,c))
    {
.        ifprefix = "else "
.      else
.        ws = ""
    // react to any incoming message
.      endif
.
.      for response
    $(ws)send$(name:Pascal)();
.      endfor
.
.      for pparams
    $(ws)if (rx.has_pparams())
    $(ws){
        $(ws)ProtocolParameters pparams = rx.pparams();
        $(ws)m_heartbeatInterval = pparams.keepalive_timer();
    $(ws)}
.      endfor
.
.      for note

    $(ws)// update error string with note
    $(ws)m_errorString = "";
    $(ws)for (int i = 0; i < rx.note_size(); ++i)
    $(ws){
        $(ws)m_errorString.append(QString::fromStdString(rx.note(i)) + "\\n");
    $(ws)}
    $(ws)emit errorStringChanged(m_errorString);
.      endfor
.
.      ifprefix2 = ""
.      for event

    $(ws)$(ifprefix2)if (m_state == State::$(when:Pascal))
    $(ws){
        $(ws)emit fsm$(when:Pascal)$(name:Pascal)(QPrivateSignal());
    $(ws)}
.        ifprefix2 = "else "
.      endfor
.
.      if (defined(public) & public = "true")
.        if ((socket.type = "SUB") | (socket.type = "ROUTER"))
    $(ws)handle$(name:Pascal)Message(topic, rx);
.        else
    $(ws)handle$(name:Pascal)Message(rx);
.        endif
.      endif
.
.      if (defined(ignore) & ignore = "true")
    $(ws)return; // $(incoming.name:) is uninteresting
.       endif
.      if (name <> "*")
    }
.      endif
.    endif
.  endfor
.

.  if ((type = "SUB") | (type = "ROUTER"))
    emit $(name)MessageReceived(topic, rx);
.  else
    emit $(name)MessageReceived(rx);
.  endif
}
.endfor
.
.for socket where (count(outgoing) > 0)

.  if ((type = "XPUB") | (type = "ROUTER"))
void $(class.name:lower,Pascal)::send$(Name)Message(const QByteArray &topic, ContainerType type, Container &tx)
.  else
void $(class.name:lower,Pascal)::send$(Name)Message(ContainerType type, Container &tx)
.  endif
{
.  if !defined(socket.class)
    if (m_socket == nullptr) {  // disallow sending messages when not connected
        return;
    }

.  endif
.  if defined(socket.class)
.    if ((type = "XPUB") | (type = "ROUTER"))
    m_$(name)Channel->sendSocketMessage(topic, type, tx);
.    else
    m_$(name)Channel->sendSocketMessage(type, tx);
.    endif
.  else
    tx.set_type(type);
#ifdef QT_DEBUG
    std::string s;
    gpb::TextFormat::PrintToString(tx, &s);
    DEBUG_TAG(3, m_debugName, "sent message" << QString::fromStdString(s));
#endif
    try {
.    if ((type = "XPUB") | (type = "ROUTER"))
        QList<QByteArray> message;
        message.append(topic);
        message.append(QByteArray::fromRawData(tx.SerializeAsString().c_str(), tx.ByteSize()));
        m_socket->sendMessage(message);
.    else
        m_socket->sendMessage(QByteArray::fromRawData(tx.SerializeAsString().c_str(), tx.ByteSize()));
.    endif
    }
    catch (const zmq::error_t &e) {
        const QString errorString = QString("Error %1: ").arg(e.num()) + QString(e.what());
        qCritical() << errorString;
.-      TODO: updateState(SocketError, errorString);  TODO
        return;
    }
    tx.Clear();
.  endif
.
.  ifprefix = ""
.  for outgoing where ((count(event) > 0))
.    if (name <> "*")
.      ws = "    "
    $(ifprefix)if (type == $(class.msg_prefix + " " + name:upper,c))
    {
.    else
.      ws = ""
.    endif
.
.    ifprefix2 = ""
.    for event

    $(ws)$(ifprefix2)if (m_state == State::$(when:Pascal))
    $(ws){
        $(ws)emit fsm$(when:Pascal)$(Name:Pascal)(QPrivateSignal());
    $(ws)}
.      ifprefix2 = "else "
.    endfor
.    if (name <> "*")
    }
.    endif
.    ifprefix = "else "
.  endfor
}
.endfor
.
.for socket
.  for outgoing where (name <> "*")

.    if ((socket.type = "XPUB") | (socket.type = "ROUTER"))
.      if defined(public)
void $(class.name:lower,Pascal)::send$(name:Pascal)(const QByteArray &topic, Container &tx)
{
    send$(socket.Name)Message(topic, $(class.msg_prefix + " " + name:upper,c), tx);
.      else
void $(class.name:lower,Pascal)::send$(name:Pascal)()
{
    Container &tx = m_$(socket.name)Tx;
    for (const auto &topic: m_$(socket.name)Topics) {
        send$(socket.Name)Message(topic, $(class.msg_prefix + " " + name:upper,c), tx);
    }
.      endif
}
.    else
.      if defined(public)
void $(class.name:lower,Pascal)::send$(name:Pascal)(Container &tx)
{
.      else
void $(class.name:lower,Pascal)::send$(name:Pascal)()
{
    Container &tx = m_$(socket.name)Tx;
.      endif
    send$(socket.Name)Message($(class.msg_prefix + " " + name:upper,c), tx);
}
.    endif
.  endfor
.
.  if !defined(socket.class)

void $(class.name:lower,Pascal)::socketError(int errorNum, const QString &errorMsg)
{
    const QString errorString = QString("Error %1: ").arg(errorNum) + errorMsg;
    qCritical() << errorString;
.-  TODO: updateState(SocketError, errorString);  TODO
}
.  endif
.endfor
.
.for fsm
.  for state

void $(class.name:lower,Pascal)::fsm$(Name)()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "State $(NAME)");
#endif
    m_state = State::$(name:Pascal);
    emit stateChanged(m_state);
}
.    for entry
void $(class.name:lower,Pascal)::fsm$(Name)Entry()
{
.      for action
    $(action.name:Camel)();
.      endfor
}
.    endfor
.    for exit
void $(class.name:lower,Pascal)::fsm$(Name)Exit()
{
.      for action
    $(action.name:Camel)();
.      endfor
}
.    endfor
.    for event

void $(class.name:lower,Pascal)::fsm$(state.Name)$(Name:Pascal)Event()
{
    if (m_state == State::$(state.name:Pascal))
    {
#ifdef QT_DEBUG
        DEBUG_TAG(1, m_debugName, "Event $(NAME)");
#endif
.      if state.name <> next
        // handle state change
        emit fsm$(state.Name)Exited(QPrivateSignal());
        fsm$(Next)();
        emit fsm$(Next)Entered(QPrivateSignal());
.      endif
        // execute actions
.      for action
        $(action.name:Camel)();
.      endfor
     }
}
.    endfor
.  endfor
.endfor
.
.for socket where (defined(socket.class) & (count(state) > 0))

void $(class.name:lower,Pascal)::$(name)ChannelStateChanged($(socket.module:Pascal,lower)::$(socket.class:lower,Pascal)::State state)
{
.  ifprefix = ""
.  for state where (count(event) > 0)

    $(ifprefix)if (state == $(socket.module:Pascal,lower)::$(socket.class:lower,Pascal)::State::$(name:Pascal))
    {
.     ifprefix2 = ""
.     for event
        $(ifprefix2)if (m_state == State::$(when:Pascal))
        {
            emit fsm$(when:Pascal)$(name:Pascal)(QPrivateSignal());
        }
.       ifprefix2 = "else "
.     endfor
    }
.    ifprefix = "else "
.  endfor
}
.endfor
.
.for trigger

/** $(name:) trigger function */
void $(class.name:lower,Pascal)::$(name:Camel)()
{
.  ifprefix = ""
.  for event
    $(ifprefix)if (m_state == State::$(when:Pascal)) {
        emit fsm$(when:Pascal)$(name:Pascal)(QPrivateSignal());
    }
.    ifprefix = "else "
.  endfor
}
.endfor

} } // namespace $(class.project:Pascal,lower)::$(class.module:Pascal,lower)
.endtemplate
